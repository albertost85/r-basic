---
title: "08_Datos_Cuantitativos"
output: html_document
---

# Descripción de datos cuantitativos

## Datos cuantitativos

Los datos cuantitativos suelen dividirse en discretos y continuos. En la práctica, y dado que no existe la precisión infinita en los ordenadores, esta distinción se diluye. Pero la división es necesaria para saber cuando aplicar técnicas de análisis de datos continuos y técnicas de análissi para datos discretos. 

Se pueden trabajar con los datos observados, o con dstos agrupados. 

## ¿Se puede trabajar con frecuencias de datos cuantitativos?
- No es necesario crear niveles para todos los niveles no observados. Sólo se estudian las frecuencias observadas.
- Se pueden agrupar los datos en un orden.

En general, supongamos que tenemos $n$ observaciones de una propiedad que se mide con un número real y obtenemos la variable cuantitativa formada por los datos 
$$x_1,\dots, x_n$$

Sean ahora $X_1,\dots,X_k$ los valores distintos que aparecen en esta lista de datos y considerémoslos ordenados


- La frecuencia absoluta de $X_i$ es el número $n_i$ de elementos que son iguales a $X_i$
- La frecuencia relativa de $X_i$ es $f_i=\frac{n_i}{n}$
- La frecuencia absoluta acumulada de $X_i$ es $N_i=\sum_{j=1}^in_j$
- La frecuencia relativa acumulada de $X_i$ es $F_i=\frac{N_i}{n}$



Lanzamos 25 veces un dado de 6 caras y anotamos las puntuaciones obtenidas en cada tirada.

En este caso, $n=25$ y, los distintos valores observados son 

$$X_1 = 1,\ X_2 = 2,\ X_3 = 3,\ X_4 = 4,\ X_5 = 5,\ X_6 = 6$$

Nos interesa ahora calcular las frecuencias de este experimento. Además, las organizaremos en un data frame para observarlas de forma más clara y sencilla en una tabla.
</div>

```{r}
set.seed(162017)
dados = sample(1:6,25,replace = TRUE)
dados
set.seed(NULL) # Para no usar de nuevo el mismo 'seed'
table(dados)
round(prop.table(table(dados)),2)
cumsum(table(dados))
round(cumsum(prop.table(table(dados))),2)
dados.df = data.frame(Puntuacion = 1:6,
                      Fr.abs = as.vector(table(dados)),
                      Fr.rel = as.vector(round(prop.table(table(dados)),2)),
                      Fr.acu = as.vector(cumsum(table(dados))),
                      Fr.racu = as.vector(round(cumsum(prop.table(table(dados))),2)))
```
La tabla de frecuencias
```{r}
dados.df
``` 

### ¿Por qué se han transformado las tablas a vectores?
Para entrar una tabla unidimensional como una variable en un data frame, es conveniente transformarla en vector con `as.vector`. Si no, cada `table` y cada `prop.table` añadirían una columna extra con los nombres de los niveles.


## Medidas de tendencia central
Son aquellas que dan un valor representativo de todas las representaciones.
- Media aritmética o valor medio, se denota por $\bar{x}$
- Mediana, representa el valor central en la lista ordenadas de observaciones (con repetición).
- Moda, es el valor de máxima frecuencia.

### ¿Cuantos tipos de medias existen?
* Existe también la media geométrica, o la media aritmética ponderada, o la media armónica
Todas están comprendidas entre el mínimo y el máximo de los datos.
Si todos los valores son iguales, las medias son iguales a ese valor.
La media aritmética, que también se llama promedio

```{r}
x = c(32, 45, 67, 43, 28, 17, 48, 95)
n_x = length(x)
x_mean = sum(x)/n_x
x_mean
```



## Media aritmética ponderada
Otorga peso al estudio.
$$\bar{x}_w = \frac{\sum_{i=1}^nw_i\cdot x_i}{\sum_{i=1}^n w_i}$$

```{r}
w_x = c(1, 2, 2, 3, 3, 2, 2, 1)
x_mean_w = sum(w_x*x)/sum(w_x)
x_mean_w
```


## Media geométrica
Útil cuando el conjunto de datos interpretados se su usan multiplicándose.
$$\bar{x}_G = \left(\prod_{i=1}^n x_i\right)^{1/n}$$


```{r}
prod(x)^(1/n_x)
prod(x^(1/n_x)) # lo mismo, la raíz de un producto es el producto de raices
```

## Media armónica
Es un promedio útil con conjuntos definidos en relación a alguna unidad. ¡Cuidado con valores cero!
$$\bar{x}_A = \frac{n}{\sum_{i=1}^{n}\frac{1}{x_i}}$$

```{r}
n/sum(1/x)
```


### Mediana
La definición formal de la mediana es la siguiente. Denotando por $$x_{(1)}\le x_{(2)}\le\dots\le x_{(n)}$$ los datos de la variable cuantitativa ordenados de menor a mayor, la mediana es

- Si $n$ par, la medio de los dos datos centrales $$\frac{x_{(\frac{n}{2})}+x_{(\frac{n}{2}+1)}}{2}$$
- Si $n$ impar, el dato central $x_{(\frac{n+1}{2})}$

```{r}
median(dados)
```


### Media aritmética

$$\bar{x} = \frac{1}{n}\sum_{i=1}^n x_i$$.
```{r}
mean(dados)
```

### Moda
Es conveniente convertirlo a número, ya que la función coge la etiqueta del dataframe o table. 
```{r}
as.numeric(names(which(table(dados) == max(table(dados)))))
```

## Medidas de posición
Estiman qué valores dividen la población en determinadas proporciones, que se llaman cuantiles.

La mediana es también una medida de posición, pues divide la población en dos.


Dada una proporción $p\in(0,1)$, el *cuantil de orden* de una variable cuantitativa, $Q_p$, es el valor más pequeño tal que su frecuencia relativa acumulada es mayor o igual a $p$.

```{r}
set.seed(260798)
dado = sample(1:4, 50, replace = TRUE)
set.seed(NULL)
length(dado)
dado = sort(dado) #Los ordenamos de menor a mayor
df.dado = data.frame(Puntuacion = 1:4,
                      Fr.abs = as.vector(table(dado)),
                      Fr.rel = as.vector(round(prop.table(table(dado)),2)),
                      Fr.acu = as.vector(cumsum(table(dado))),
                      Fr.racu = as.vector(round(cumsum(prop.table(table(dado))),2)))

df.dado
```


Si nos piden el cuantil $Q_{0.3}$, sabemos que este es el primer elemento de la lista cuya frecuencia relativa acumulada es mayor o igual a 0.3. Este se corresponde con la puntuación 1.

En cuanto a la mediana, sería el primer valor cuya frecuencia acumulada relativa fuese mayor a 0.5; en el caso anterior, 2. 

## Cuantiles con nombre propio

Algunos cuantiles tienen nombre propio:

- Los cuartiles son los 3 cuantiles $Q_{0.25},Q_{0.5}$ y $Q_{0.75}$ que dividen los datos en cuartos.
- El cuantil $Q_{0.5}$ es la mediana
- Los deciles son 9 y son los cuantiles $Q_p$ con $p$ un múltiplo de 0.1.
- Los percentiles son los 99 cuantiles $Q_p$ con $p$ un múltiplo de 0.01.

## Cuantiles en R
No hay consenso sobre cómo calcular los cuantiles. en R, la función quantile admite un parámetro type = 0...8, siendo por defecto type=7 con distintos métodos para calcular cuantiles. 

```{r}
quantile(dados,0.25) #Primer cuartil
quantile(dados,0.8)
```
## Medidas de dispersión

Evalúan cuán dispersos están esos datos

- El rango es la diferencia entre el mínimo y el máximo de las observaciones.

- Como esos datos pueden ser extremos pero muy poco representativos existe el rango intercuartílico, que es la diferencia entre el primer y el tercer cuartil. 

- La varianza, a la que denotaremos por $s^2$, es la media aritmética de las diferencias al cuadrado entre los datos $x_i$ y la media aritmética de las observaciones. 
$$s^2 = \frac{\sum_{j=1}^n(x_j-\bar{x})^2}{n}=\frac{\sum_{j=1}^kn_j(X_j-\bar{x})^2}{n}=\sum_{j=1}^kf_j(X_j-\bar{x})^2$$.

- La desviación típica es la raíz cuadrada positiva de la varianza, $s=\sqrt{s^2}$.

## Propiedades de la varianza
- Siempre es mayor o igual a 0. $s^2\ge 0$. Esto se debe a que, por definición, es una suma de cuadrados de números reales.
- Sólo es 0 si todos los datos son iguales. $s^2 = 0\Longrightarrow x_j-\bar{x}=0\ \forall j= 1,\dots,n$. En consecuencia, si $s^2=0$, entonces todos los datos son iguales.
- $s^2 =\frac{\sum_{j=1}^nx_j^2}{n}-\bar{x}^2$. Es decir, la varianza es la media de los cuadrados de los datos menos el cuadrado de la media aritmética de estos.

## Varianza y desviación típica

Nótese que tanto la varianza como la desviación típica dan una información equivalente. Entonces, es comprensible preguntarse por qué se definen ambas medidas si con una basta. Pues bien, las unidades de la varianza (metros, litros, años...), ya sea muestral o no, están al cuadrado, mientras que las de la desviación típica no.

## Varianza y varianza muestral
Por un lado, es normal medir cómo varían los datos  cuantitativos mediante su varianza definida como la media aritmética de las distancias al cuadrado de los datos a su valor medio. No obstante, por otro lado, el conjunto de nuestras observaciones, por lo normal, será una muestra de una población mucho mayor y nos interesará estimar entre otras muchas cosas su variabilidad.

- La <l class = "definition">varianza muestral</l> es la corrección de la varianza. La denotamos por $\tilde{s}^2$ y se corresponde con
$$\tilde{s}^2 = \frac{n}{n-1}s^2 = \frac{\sum_{j=1}^n(x_i-\bar{x})^2}{n-1}$$
- La <l class = "definition">desviación típica muestral</l>, que es la raíz cuadrada positiva de la varianza muestral, $\tilde{s} = \sqrt{\tilde{s}^2}$

La varianza de una muestra suele dar valores más pequños que la varianza de la población, mientras que la varianza muestral tiende a dar valores alrededor de la varianza de la población.

El cociente $\frac{n-1}{n}$ tiende a 1 con muestras muy grandes. 

Esta corrección, para el caso de una muestra grande no es notable.

En cambio, si la muestra es relativamente pequeña (digamos $n<30$), entonces la varianza muestral de la muestra aproxima significativamente mejor la varianza de la población que la varianza.

Con `R`, calcularemos la varianza y la desviación típica **muestrales**. Con lo cual, si queremos calcular las que no son muestrales, tendremos que multiplicarlas por $\frac{n-1}{n}$, donde $n$ es el tamaño de la muestra. Lo veremos a continuación.

## Fórmula alternativa de la varianza.
- Dado el conjunto $x$ de $n$ muestras $x_0, x_1, ..., x_n$.
- La media aritmética $\bar{x}$ de esas muestras calculada como $\bar{x} = \frac{\sum_{i=1}^n x_i}{n}$

$$s^2 = \frac{\sum_{i=1}^n(x_i - \bar{x})^2}{n}$$

Se puede calcular la varianza como:
$$s^2 = \frac{\sum_{i=1}^n x^2_i}{n} - (\bar{x})^2  = \bar{x^2} - (\bar{x})^2$$
### Demostración
Partiendo de la definición
$$n \cdot s^2 = \sum_{i=1}^n(x_i - \bar{x})^2 = \sum_{i=1}^n(x_i^2 - 2x_i\cdot\bar{x} + (\bar{x})^2) $$

$$n \cdot s^2  = \sum_{i=1}^n(x_i^2) - 2\bar{x}\sum_{i=1}^n(x_i) + n\cdot (\bar{x})^2$$

Dividiendo entre n, podemos expresar los sumatorios como medias aritméticas

$$ n \cdot s^2  = n \bar{x^2} - 2n(\bar{x})^2 + n\cdot (\bar{x})^2 $$
$$ s^2 = \bar{x^2} - (\bar{x})^2$$

## Medidas de dispersión con R

Medida de dispersión |  Instrucción                                
--------------------|--------------------
Valores mínimo y máximo | `range(x)` 
Rango | `diff(range(x))` 
Rango intercuartílico | `IQR(x, type = ...)`
Varianza muestral | `var(x)` 
Desviación típica muestral | `sd(x)` 
Varianza | `var(x)*(length(x)-1)/length(x)` 
Desviación típica | `sd(x)*sqrt((length(x)-1)/length(x))` 

La función `summary` aplicada a un vector numérico o a una variable cuantitativa nos devuelve un resumen estadístico con los valores mínimo y máximo del vector, sus tres cuartiles y su media.

Al aplicar esta función a un data frame, esta se aplica a todas sus variables de forma simultánea. De este modo, podemos observar rápidamente si hay diferencias notables entre sus variables numéricas. Produce distintas salidas en función de si se aplica a un gráfico, a un dataframe, a una tabla, etc. 

```{r}
cangrejos = read.table("data/datacrab.txt", header = TRUE) #Cargamos el data frame
cangrejos = cangrejos[-1] #Eliminamos la primera columna
summary(cangrejos) #Aplicamos la función summary
```

Si nos interesase comparar numéricamente los pesos y las anchuras de los cangrejos con 3 colores con los que tienen 5 colores, utilizaríamos las siguientes instrucciones:


```{r}
cangrejos_3_colores = summary(subset(cangrejos, color == 3,c("weight","width")))
cangrejos_5_colores = summary(subset(cangrejos, color == 5,c("weight","width")))
print(cangrejos_3_colores)
print(cangrejos_5_colores)
```

### La función by()

La función `by()` se utiliza para aplicar una determinada función a algunas columnas de un data frame segmentándolas según los niveles de un factor.

La sintaxis de esta función es `by(columnas, factor, FUN = función)`.

Con lo cual, haciendo uso de la función `by` y especificando `FUN = summary`, podremos calcular el resumen estadístico anteriormente comentado a subpoblaciones definidas por los niveles de un factor.


```{r, results="hide"}
by(cangrejos$weight, cangrejos$color == 2, FUN = summary)
```
### Aggregate
Es similar a by, pero no sé qué dice, de hecho no produce nada por consola, y hay que asignarle una variable y abrirla para ver qué hay dentro. 
```{r}
a = aggregate(cbind(Sepal.Length,Petal.Length)~Species, 
          data=iris, FUN=summary)
```

### NA

La mayoría de las funciones vistas a lo largo de este tema no funcionan bien con valores `NA`.

Para no tenerlos en cuenta a la hora de aplicar estas funciones, hay que especificar el parámetro `na.rm = TRUE` en el argumento de la función.

## Representación gráfica de datos cuantitativos

## Diagramas de caja

El conocido diagrama de caja es un tipo de gráfico que básicamente, remarca 5 valores estadísticos:

- La mediana, representada por la línea gruesa que divide la caja
- El primer y tercer cuartil, que son los lados inferior y superior, respectivamente. De este modo, la altura de la caja es el rango intercuantílico
- Los extremos, los valores $b_{inf},b_{sup}$, son los bigotes del gráfico. Si $m$ y $M$ son el mínimo y máximo de la variable cuantitativa, entonces los extremos se calculan del siguiente modo:
$$b_{inf}=\max\{m,Q_{0.25}-1.5(Q_{0.75}-Q_{0.25})\}$$
$$b_{sup}=\min\{M,Q_{0.75}+1.5(Q_{0.75}-Q_{0.25})\}$$
- Valores atípicos son los que están más allá de los bigotes. Se marcan como puntos aislados.


## La función boxplot

La instrucción `boxplot()` dibuja diagramas de caja en R.

```{r}
dados = sample(1:6,25,replace = TRUE)
dados2 = sample(1:4, 50, replace = TRUE)
boxplot(dado,dados,dados2, main = "Un diagrama de caja")
```


Además, podemos dibujar el diagrama de caja de todas las variables de un data frame en un solo paso aplicando la instrucción `boxplot(data.frame)`.

```{r, fig.width=10, fig.height=5}
body = read.table("data/bodyfat.txt", header = TRUE)
boxplot(body[,7:9], names = c("Pecho", "Abdomen", "Cadera"))
```
## Diagramas de cajas comparando una variable por factores.

Agrupar varios diagramas de caja en un solo gráfico tiene por objetivo poder compararlos visualmente, lo cual tiene sentido cuando las variables tienen significados parecidos o cuando comparamos una misma variable de poblaciones distintas.

La mayoría de las veces, querremos comparar diagramas de cajas de una misma variable cuantitativa (circunferencia) segmentada por los niveles de un factor (Tree, o tipo de naranjo): circumference~Tree

```{r}
boxplot(circumference~Tree, data = Orange, ylab = "Circunferencia del tronco (mm)", 
        main = "Boxplot de los naranjos en función del tipo de árbol")
```

## Parámetros de la función boxplot
En general, admite los mismos parámetros que un plot, como main, col, xlim, etc.
- `notch` igualado a `TRUE` añade una muesca en la mediana de la caja.

Si quisiéramos marcar de alguna forma en un diagrama de caja, cosa que puede ser muy útil en ocasiones, la media aritmética de la variable correspondiente, podríamos hacerlo mediante la función `points`.

```{r}
bp_iris = boxplot(Sepal.Width~Species, data = iris, ylab = "Anchura del sétalo (cm)",
        notch = TRUE, col = c("cyan","cyan2","cyan4"),
        main = "Boxplot de iris")
medias = aggregate(Sepal.Width~Species, data = iris, FUN = mean)
points(medias, col = "blue", pch = 21)
```

La primera instrucción del chunk anterior genera el diagrama de cajas de las anchuras de los sépalos en función de la especie. Por su parte, la segunda instrucción lo que hace es calcular las medias aritméticas de las anchuras según la especie. Finalmente, la tercera instrucción lo que hace es añadir al diagrama un punto cuadrado a cada caja en la ordenada correspondiente a su media aritmética.

## La estructura interna de boxplot

La estructura de un boxplot puede examinarse mediante la función 'str'. Destacan algunos elementos de interés:
- `stats` nos devuelve los valores $b_{inf},\ Q_{0.25},\ Q_{0.5},\ Q_{0.75},\ b_{sup}$
- `out` nos retorna los valores atípicos. En caso de haber diversos diagramas en un plot, la componente `group` nos indica a qué diagramas pertenecen estos outliers.
```{r}
str(bp_iris)
```

# Necesidad de agrupar datos cuantitativos
Hay una necesidad de agrupar datos en categorías. Ayuda a interpretar el significado.
En datos muy heterogéneos, nos encontraríamos con que las frecuencias de los valores individuales serían todas muy similares.


```{r}
pesos = c(55.2,54.0,55.2,53.7,60.2,53.2,54.6,55.1,51.2,53.2,54.8,52.3,56.9,57.0,55.0,
          53.5,50.9,55.1,53.6,61.2,59.5,50.3,52.7,60.0)
```

## Cómo agrupar datos


Antes de estudiar unos datos agrupados, hay que, obviamente, agruparlos. Este proceso consta de 4 pasos:

1. Decidir el número de intervalos que vamos a utilizar
2. Decidir la amplitud de estos intervalos
3. Acumular los extremos de los intervalos
4. Calcular el valor representativo de cada intervalo, su <l class = "definition">marca de clase</l>

No hay una forma de agrupar datos mejor que otra. Eso sí, cada uno de los diferentes agrupamientos para un conjunto de datos podría sacar a la luz características diferentes del conjunto.



## La función hist()

La función de R por excelencia para estudiar datos agrupados es `hist`. Dicha función implementa los 4 pasos del proceso.

Si le indicamos como argumentos el vector de datos y el número de intervalos que deseamos, o bien el método para determinarlo (cosa que veremos a continuación), la función agrupará los datos en el número de clases que le hemos introducido, más o menos. Eso sí, sin control de ningún tipo por nuestra parte sobre los intervalos que produce.

Esto puede venirnos bien en algunos casos, pero no en otros.

## Estableciendo el número de clases

En este tema explicaremos una receta para agrupar datos. Lo dicho, ni mejor ni peor que el resto.

Lo primero es establecer el número $k$ de clases en las que vamos a dividir nuestros datos. Podemos decidir en función de nuestros intereses o podemos hacer uso de alguna de las reglas existentes. Destacaremos las más populares. Sea $n$ el número total de datos de la muestra

### Regla de la raíz cuadrada
La parte entera de la raíz cuadrada de datos

$$k = \lceil \sqrt{n} \rceil$$

### Regla de Sturges
Valor absoluto de 1 + el logaritmo en base 2
$$k = \lceil 1+\log_{2}(n)\rceil$$
```{r}
nclass.Sturges
```

### Regla de Scott
Se determina primero la amplitud teórica, $A_S$, de las clases en función de la desviación típica muestral $\tilde{s}$.
$$A_S = 3.5\cdot\tilde{s}\cdot n^{-\frac{1}{3}}$$
Luego se toma 
$$k = \left\lceil \frac{\max(x)-\min(x)}{A_S}\right\rceil$$
```{r}
nclass.scott
```

### Regla de Freedman-Diaconis
Se determina primero la amplitud teórica $A_{FD}$ en función del primer y el tercer cuartil:
$$A_{FD} = 2\cdot(Q_{0.75}-Q_{0.25})\cdot n^{-\frac{1}{3}}$$

Y entonces 
$$k = \left\lceil \frac{\max(x)-\min(x)}{A_{FD}}\right\rceil$$


## Decidiendo la amplitud

Una vez determinado $k$, hay que decidir su amplitud. 

### Amplitud única
La forma más fácil y la que nosotros utilizaremos por defecto es que la amplitud de todos los intervalos sea la misma, $A$, dividiendo el rango de los datos entre $k$, el número de clases, y redondearemos por exceso a un valor de la precisión de la medida.


## Extremos de los intervalos
### Convención [)
Es la hora de calcular los extremos de los intervalos. Nosotros tomaremos estos intervalos siempre cerrados por su izquierda y abiertos por la derecha, debido a que esta es la forma en que R los construye y porque es así como se utilizan en Teoría de Probabilidades al definir la distribución de una variable aleatoria discreta y también en otras muchas situaciones cotidianas.

Utilizaremos la siguiente notación
$$[L_1,L_2),[L_2,L_3),\dots,[L_k,L_{k+1})$$

donde los $L_i$ denotan los extremos de los intervalos. Estos se calculan de la siguiente forma:

- $$L_1 = \min(x)-\frac{1}{2}\cdot \text{precisión}$$
De esta forma garantizamos que los extremos de los intervalos nunca coincidan con valores del conjunto de datos, puesto que tinen una precisión mayor.

- A partir de $L_1$, el resto de intervalos se obtiene de forma recursiva:
$$L_2 = L_1 + A$$
$$L_3 = L_2 + A$$
$$\vdots$$
$$L_{k+1} = L_k+A$$

Si nos fijamos bien, los extremos forman una progresión aritmética de salto $A$: 
$$L_{i} = L_{1}+(i-1)A,\qquad i=2,\dots,k+1$$



## Marca de clase
La marca de clase es un valor $X_i$ del intervalo que se utiliza para identificar la clase de cada intervalo $[L_i,L_{i+1})$

Genralmente, $X_i$ será el punto medio del intervalo, para así garantizar que el error máximo cometido al describir cualquier elemento del intervalo por medio de su marca de clase sea mínimo o igual a la mitad de la amplitud del respectivo intervalo.
$$X_i = \frac{L_i+L_{i+1}}{2}$$
## **Ejemplo 2**

Vamos a considerar el conjunto de datos de `datacrab`. Para nuestro estudio, trabajaremos únicamente con la variable `width`.

Cargamos los datos en un data frame:
A continuación, definimos la variable `cw` que contiene los datos de la variable `width`.

```{r}
crabs = read.table("data/datacrab.txt", header = TRUE)
str(crabs)
cw = crabs$width
```



Calculemos el número de clases según las diferentes reglas que hemos visto:

- Regla de la raíz cuadrada:

```{r}
n = length(cw)
k1 = ceiling(sqrt(n))
k1
```

- Regla de Sturges:

```{r}
k2 = ceiling(1+log(n,2))
k2
nclass.Sturges(cw)
```

- Regla de Scott:

```{r}
As = 3.5*sd(cw)*n^(-1/3) #Amplitud teórica
k3 = ceiling(diff(range(cw))/As)
k3
nclass.scott(cw)
```

- Regla de Freedman-Diaconis:

```{r}
#Amplitud teórica
Afd = 2*(quantile(cw,0.75, names = FALSE)-quantile(cw,0.25,names = FALSE))*n^(-1/3) 
k4 = ceiling(diff(range(cw))/Afd)
k4
nclass.FD(cw)
```

De momento, vamos a seguir la Regla de Scott. Es decir, vamos a considerar `r nclass.scott(cw)` intervalos.

A continuación, debemos elegir la amplitud de los intervalos. Como nuestros datos están expresados en mm con una precisión de una cifra decimal, debemos redondear por exceso a un cifra decimal el resultado obtenido. Por lo tanto, nuestra amplitud será de 

```{r}
A = diff(range(cw)) / k3
A = floor(A*10 + 0.5)
A = A/10
A
```

Calculamos el primer extremo con una precisión de 0.1:

```{r}
L1 = min(cw)-1/2*0.1
L1
```

donde 0.1 es nuestra precisión (décimas de unidad, en este caso).

```{r}
L = L1 + A*(0:10)
L
```

Así, nuestros intervalos serán los siguientes:

$$[20.95,22.25),\ [22.25,23.55),\ [23.55,24.85),\ [24.85,26.15),\ [26.15,27.45),$$ $$[27.45,28.75),\ [28.75,30.05),\ [30.05,31.35),\ [31.35,32.65),\ [32.65,33.95)$$

Y hemos llegado al úlitmo paso: calcular las marcas de clase.

Empecemos calculando $X_1$

```{r}
X1 = (L[1]+L[2])/2
X1
X = X1 + A*(0:9)
X
```

## Agrupando los datos con R
Se pueden agrupar los datos en R con la función cut(x, breaks=, labels=, right=)
- `x` es el vector numérico, nuestra variable cuantitativa
- `breaks` puede ser un vector numérico formado por los extremos de los intervalos en los que queremos agrupar nuestros datos y que habremos calculado previamente. También puede ser un número $k$, en cuyo caso R agrupa los datos en $k$ clases. Para este caso, R divide el intervalo comprendido entre los valores mínimo y máximo de $x$ en $k$ intervalos y, a continuación, desplaza ligeramente el extremo inferior del primer intervalo a la izquierda y el extremo del último, a la derecha.
- `labels` es un vector con las etiquetas de los intervalos. Su valor por defecto es utilizar la etiqueta de los mismos intervalos. Si especificamos `labels = FALSE`, obtendremos los intervalos etiquetados por medio de los números naturales correlativos.
- `right` , por defecto es TRUE y hace que los intervalos sean cerrados por la derecha; hay que darle el valor explícito "FALSE" para hacer intervalos cerrados por la izquierda y abiertos por la derecha, como en teoría de probabilidades.
- `include.lowest` igualdo a `TRUE` combinado con `right = FALSE` hace que el último intervalo sea cerrado. Puede sernos útil en algunos casos.

```{r}
iris_df = iris
petals = iris$Petal.Length
iris_df$div1 = cut(petals, breaks = ceiling(sqrt(length(petals))), right=FALSE)
iris_df$div2 = cut(petals, breaks = 6, labels=c("XS","S","M","L","XL","XXL"), right=FALSE)
iris_df
```


Una primera consideración es tratar las clases obtenidas en el paso anterior como los niveles de una variable ordinal y calcular sus frecuencias.

- La frecuencia absoluta de una clase será el número de datos originales que pertenecen a la clase
- La frecuencia absoluta acumulada de una clase será el número de datos que pertenecen a dicha clase o alguna de las anteriores

## Codificar los niveles
pen R los datos agrupados quedan clasificados por factores. Las etiquetas de estos factores pueden ser:
- Los niveles (por defecto)
- Las marcas de clase
- Un número de orden asignado a cada intervalo.

## Frecuencias de un conjunto de datos agrupados
Normalmente, las frecuencias de un conjunto de datos agrupados se suele representar de la siguiente forma

| Intervalos | $X_j$ | $n_j$ | $N_j$ | $f_j$ | $F_j$ |  
|-------------------|--------------------|--------------------|--------------------|--------------------|--------------------|
|$[L_1,L_2)$|$X_1$|$n_1$|$N_1$|$f_1$|$F_1$|
|$[L_2,L_3)$|$X_2$|$n_2$|$N_2$|$f_2$|$F_2$|
|$\vdots$|$\vdots$|$\vdots$|$\vdots$|$\vdots$|$\vdots$|
|$[L_k,L_{k+1})$|$X_k$|$n_k$|$N_k$|$f_k$|$F_k$|

- $X_j$ es la marca de clase
- El resto de la nomenclatura ya se ha explicado, son frecuencias. n/N son freq absolutas y f/F son relativas. N/F son, además, acumuladas. 

El cálculo de las frecuencias con R podemos hacerlo mediante las funciones `table`, `prop.table` y `cumsum`.


### Histogramas

También podemos utilizar la función `hist`, que internamente genera una list cuya componente `count` es el vector de frecuencias absolutas de las clases. Por consiguiente, para calcular estas frecuencias, podemos utilizar la sintaxis

hist(x, breaks=..., right=FALSE, plot=FALSE)$count

cut y hist dividen el conjunto de datos de forma diferente, por lo que es conveniente *igualar el parámetro braks al vector de extremos del intervalo*

El resultado de `hist` incluye la componente `mids` que contiene el vector de puntos medios de los intervalos, es decir, nuestras marcas de clase.

### Función para dividir datos en segmentos iguales

Sirve en el caso en que vayamos a tomar todas las clases de la misma amplitud. Sus parámetros son: 
- $x$, el vector con los datos cuantitativos; 
- $k$, el número de clases; 
- $A$, su amplitud; y 
- $p$, la precisión de los datos (p = 1 si la precisión son unidades, p = 0.1 si la precisión son décimas de unidad...).

```{r}
#Primera función
TablaFrecs = function(x,k,A,p){ 
  L = min(x)-p/2+A*(0:k)
  x_cut = cut(x, breaks = L, right=FALSE)
  intervals = levels(x_cut)
  mc = (L[1]+L[2])/2+A*(0:(k-1))
  Fr.abs = as.vector(table(x_cut)) 
  Fr.rel = round(Fr.abs/length(x),4) 
  Fr.cum.abs = cumsum(Fr.abs) 
  Fr.cum.rel = cumsum(Fr.rel)
  tabla = data.frame(intervals, mc, Fr.abs, Fr.cum.abs, Fr.rel, Fr.cum.rel)
  tabla
}

```

La tabla de frecuencias de la longitud de los pétalos de *Iris* es:
```{r}
TablaFrecs(petals, k=6, A=1, p=0.1)
```


### Función para dividir datos en segmentos preestablecidos.
Cuando conocemos los extremos de las clases. Sus parámetros son: 
- $x$, el vector con los datos cuantitativos; 
- $L$, el vector de extremos de clases; y 
- $V$ , un valor lógico, que ha de ser `TRUE` si queremos que el último intervalo sea cerrado, y `FALSE` en caso contrario.

```{r}
TablaFrecs.L = function(x,L,V){
  x_cut = cut(x, breaks=L, right=FALSE, include.lowest=V)
  intervals = levels(x_cut)
  mc = (L[1:(length(L)-1)]+L[2:length(L)])/2
  Fr.abs = as.vector(table(x_cut)) 
  Fr.rel = round(Fr.abs/length(x),4)
  Fr.cum.abs = cumsum(Fr.abs)
  Fr.cum.rel = cumsum(Fr.rel)
  tabla = data.frame(intervals, mc, Fr.abs, Fr.cum.abs, Fr.rel, Fr.cum.rel)
  tabla
}

```

La tabla de frecuencias de la longitud de los pétalos de *Iris* es:
```{r}
TablaFrecs.L(petals, L=1:7, V=FALSE)
```


Nnotas de un examen de historia a los 100 alumnos de primero de bachillerato de un instituto.

Vamos a hacer uso de todo lo aprendido para obtener la mayor información posible utilizando las funciones `cut` e `hist` y también, las proporcionadas por nosotros.

Los resultados obtenidos en la encuesta han sido:

```{r, echo = FALSE}
set.seed(4)
notas = sample(0:10,100, replace = TRUE)
set.seed(NULL)
notas
```
Vamos a agrupar las notas en los siguientes intervalos:

$$[0,5),\ [5,7),\ [7,9),\ [9,10]$$

Claramente, estos 4 intervalos no tienen la misma amplitud.

Fijémonos también en que el último intervalo está cerrado por la derecha.


```{r}
#Definimos vector de extremos
L = c(0,5,7,9,10)
#Definimos notas1 como el resultado de la codificación en intervalos utilizando como 
#etiquetas los propios intervalos
notas1 = cut(notas, breaks = L, right = FALSE, include.lowest = TRUE)
notas1
```

Ahora las notas se muestran en función de su marca de clase
```{r}
#Definimos las marcas de clase
MC = (L[1:length(L)-1]+L[2:length(L)])/2
#Definimos notas2 como el resultado de la codificación en intervalos utilizando como 
#etiquetas las marcas de clase
notas2 = cut(notas, breaks = L, labels = MC, right = FALSE, include.lowest = TRUE)
notas2
```
Se pueden clasificar en función de la posición ordenada del intervalo. En este caso, las notas serán valores de un vector, y no un factor. 

```{r}
#Definimos notas3 como el resultado de la codificación en intervalos utilizando como 
#etiquetas la posición ordenada del intervalo (1, 2, 3 o 4)
notas3 = cut(notas, breaks = L, labels = FALSE, right = FALSE, include.lowest = TRUE)
notas3
```
También usando un factor de texto
```{r}
#Definimos notas4 como el resultado de la codificación en intervalos utilizando como 
#etiquetas Susp, Aprob, Not y Exc
notas4 = cut(notas, breaks = L, labels = c("Susp", "Aprob", "Not", "Exc"), right = FALSE, include.lowest = TRUE)
notas4
```

¿Qué habría ocurrido si le hubiéramos pedido a R que cortase los datos en 4 intervalos?

R repartirá los datos en 4 intervalos de longitud 2.5, y desplazará ligeramente a la izquierda el extremo izquierdo del primer intervalo. 

## Solución

```{r}
cut(notas, breaks = 4, right = FALSE, include.lowest = TRUE)

```
## Construir la tabla de frecuencias
```{r}
table(notas4) #Fr. Abs
prop.table(table(notas4)) #Fr. Rel
cumsum(table(notas4)) #Fr. Abs. Cum
cumsum(prop.table(table(notas4))) #Fr. Rel. Cum
```

Podríamos haber obtenido todo lo anterior haciendo uso de la función `hist`.

```{r}
notasHist = hist(notas, breaks = L, right = FALSE, include.lowest = TRUE, plot = FALSE)
FAbs = notasHist$count
FAbs
FRel = prop.table(FAbs)
FRel
FAbsCum = cumsum(FAbs)
FAbsCum
FRelCum = cumsum(FRel)
FRelCum
```
Ahora ya podemos crear un data frame con todas estas frecuencias:
```{r}
intervalos = c("[0,5)","[5,7)","[7,9)","[9,10]")
calificacion = c("Suspenso", "Aprobado", "Notable", "Excelente")
marcas = notasHist$mids
tabla.Fr = data.frame(intervalos,calificacion,marcas,FAbs,FAbsCum,FRel,FRelCum)
tabla.Fr
```

```{r}
TablaFrecs.L(notas, L, TRUE)
```


# Estadísticos para datos agrupados

Hay que tratar de forma diferente a los datos cuantiativos agrupados. Algunos estadísticos se deben calcular antes de agrupar los datos.

En los casos en que haya que calcular sobre datos agrupados, se pueden *aproximar* los estadísticos originales.

### Intervalo modal
- Moda, esta se sustituye por el término *intervalo modal*, incluso si se usa su marca de clase.

### Intervalo crítico
- Mediana, ésta se sustituye por *intervalo crítico*, el primer intervalo donde la frecuencia relativa acumulada sea mayor o igual que 0.5.
Si se quiere aproximar la mediana, se toman los $N_{c-n}$ frecuencia absoluta acumulada del intervalo inmediatamente anterior, $n_c$ el número de elementos del intervalo crítico
$$M = L_c +A_c\cdot\frac{\frac{n}{2}-N_{c-1}}{n_c}$$

### Aproximación de los cuantiles
De forma similar:
$$Q_p = L_p +A_p\cdot\frac{p\cdot n-N_{p-1}}{n_p}$$
### Función para aproximar un cuantil en R
También podemos hacer aproximaciones de los cuantiles. Hemos creado una función `aprox.quantile.p` para no tener que copiar la operación cada vez que queramos calcular un cuantil aproximado.
```{r}
aprox.quantile.p = function(Lcrit,Acrit,n,p,Ncrit.ant,ncrit){
  round(Lcrit+Acrit*(p*n-Ncrit.ant)/ncrit,3)
}
```

## Histogramas

O histograma de frecuencias. Es un diagrama de barras especial, ya que simboliza niveles de datos, así que las barras deben estar representadas sin separar.

El Área (y no la altura) es proporcional a la frecuencia absoluta del nivel.
Si todas las clases tienen la misma amplitud, las alturas de estas barras son proporcionales a las frecuencias de sus clases, con lo cual podemos marcar sin ningún problema las frecuencias sobre el eje vertical. Pero si las amplitudes de las clases no son iguales, las alturas de las barras en un histograma no representan correctamente las frecuencias de las clases.


Los histogramas también son utilizados para representar frecuencias acumuladas de datos agrupados. En este caso, las alturas representan las frecuencias independientemente de la base debido a que éstas deben ir creciendo.

En el eje de las abcisas se marcan loos extremos de las clases y se dibuja una barra sobre cada una de ellas.

## Interpretación de los histogramas

```{r, echo = FALSE}
crabs = read.table("data/datacrab.txt", header = TRUE)
str(crabs)
cw = crabs$width
L1 = min(cw)-1/2*0.1
A = 1.3
L = L1 + A*(0:10)

par(mfrow = c(1,2))
hist(cw, breaks = L, right = FALSE, main = "Histograma con intervalos \n de misma anchura",xlab = "")
Lnotas = c(0,5,7,9,10)
hist(notas, breaks = Lnotas, right = FALSE, include.lowest = TRUE, main = "Histograma con intervalos \n de diferente anchura", xlab = "")
par(mfrow = c(1,1))
```

No es conveniente que en un histograma aparezcan clases con frecuencia nula, exceptuando el caso en que represente poblaciones muy diferentes y separadas sin individuos intermedios. Si no, convendría utilizar un número menor de clases, o bien unir las clases vacías con alguna de sus adyacentes. De este último modo romperíamos nuestro modo de trabajar con clases de la misma amplitud.

### La función hist

Lo hacemos con la función `hist`, la cual ya conocemos.`hist` titula por defecto los histogramas del siguiente modo: "Histogram of" seguido del nombre del vector de datos. 

Su sintaxis es

`hist(x, breaks=..., freq=..., right=..., ...)`
- `x`: vector de los datos
- `breaks`: vector con los extremos de los intervalos o el número $k$ de intervalos. Incluso podemos indicar, entre comillas, el método que deseemos para calcular el número de clases: `"Scott"`, `"Sturges"`... Eso sí, para cualquiera de las dos últimas opciones, no siempre obtendréis el número deseado de intervalos, puesto que R lo considerará solo como sugerencia. Además, recordad que el método para calcular los intervalos es diferente al de la función `cut`. Por tanto, se recomienda hacer uso de la primera opción.
- `freq=TRUE`, que es su valor por defecto, produce el histograma de frecuencias absolutas si los intervalos son todos de la misma amplitud y de frecuencias relativas en caso contrario. `freq=FALSE` nos produce siempre el de frecuencias relativas.
- `right` funciona exactamente igual que en la función `cut`, true por defecto, y considera los intervalos cerrados por la derecha.
- `include.lowest = TRUE` también funciona exactamente igual que en la función `cut`.
- También podéis utilizar los parámetros de la función `plot` que tengan sentido
- 'plot = FALSE' no dibuja el histograma, pero calcula la estructura con información útil:
-- `breaks` contiene el vector de extremos de los intervalos: $L_1,\dots,L_{k+1}$
-- `counts` contiene el vector de frecuencias absolutas de los intervalos: $n_1,\dots,n_k$
-- `mids` contiene los puntos medios de los intervalos o marcas de clase
- `xaxt="n"` e `yaxt="n"` especifican que, por ahora, la función no dibuje los ejes de abcisas y ordenadas, respectivamente.


### Función para dibujar histogramas de frecuencias relativas completos y con formato

```{r}
histAbs = function(x,L) {
  h = hist(x, breaks = L, right = FALSE, freq = FALSE,
           xaxt = "n", yaxt = "n", col = "lightgray", 
           main = "Histograma de frecuencias absolutas", 
           xlab = "Intervalos y marcas de clase",ylab = "Frecuencias absolutas")
  axis(1, at=L)
  text(h$mids, h$density/2, labels=h$counts, col="purple") 
}

```
- `axis(i, at=...)` dibuja el eje correspondiente al valor de $i$ con marcas en los lugares indicados por el vector definido mediante `at`. Si $i=1$, el de abcisas; si $i=2$, el de ordenadas.

Os habréis fijado que con `freq = FALSE` en realidad hemos dibujado un histograma de frecuencias relativas, pero al haber omitido el eje de ordenadas, da lo mismo. En cambio, sí que nos ha sido útil para poder añadir, con la función `text`, la frecuencia absoluta de cada clase sobre el punto medio de su intervalo, los valores `h$mids` y a media algura de su barra, correspondiente a `h$density` gracias a que, con `freq = FALSE` estas alturas se corresponden con la densidad.

### Función rug en el histograma

Otra forma de indicar las frecuencias absolutas de las barras es utilizar la función `rug`, la cual permite añadir al histograma una "alfombra" con marcas en todos los valores del vector, donde el grosor de cada marca es proporcional a la frecuencia del valor que representa.

Existe la posibilidad de añadir un poco de ruido a los datos de un vector para deshacer posibles empates. Esto lo conseguimos combinando la función `rug` con `jitter`.

```{r, echo=FALSE}
set.seed(1)
edades = c(sample(0:99,80,replace = TRUE),rep(35,10),rep(22,5),rep(17,3),50,50)
extremos = c(0,20,40,60,80,100)
par(mfrow=c(1, 2))
histAbs(edades, extremos)
rug(edades)
histAbs(edades, extremos)
rug(jitter(edades))
par(mfrow=c(1,1))
set.seed(NULL)
```

### Función para dibujar histogramas de frecuencias acumuladas con formato

Se produce el histograma básico de los datos, sin dibujarlo para a continuación modificar la componente `density` para que contenga las sumas acumuladas de esta componente del histograma original.
Seguidamente, dibujamos el nuevo histograma resultante, aplicando la función `plot`. Es aquí donde debemos especificar los parámetros y no en el histograma original.

Finalmente, añadimos el eje de abcisas y las frecuencias acumuladas en color lila.
```{r}
histAbsCum = function(x,L) {
  h = hist(x, breaks = L, right = FALSE , plot = FALSE) 
  h$density = cumsum(h$density)
  plot(h, freq = FALSE, xaxt = "n", yaxt = "n", col = "lightgray", 
       main = "Histograma de frecuencias\nabsolutas acumuladas", xlab = "Intervalos", 
       ylab = "Frec. absolutas acumuladas")
  axis(1, at=L)
  text(h$mids, h$density/2, labels = cumsum(h$counts), col = "purple") 
  }
```

```{r, echo=FALSE}
set.seed(1)
edades = c(sample(0:99,80,replace = TRUE),rep(35,10),rep(22,5),rep(17,3),50,50)
extremos = c(0,20,40,60,80,100)
par(mfrow=c(1, 2))
histAbsCum(edades, extremos)
rug(edades)
histAbsCum(edades, extremos)
rug(jitter(edades))
par(mfrow=c(1,1))
set.seed(NULL)
```


## Histogramas de frecuencias relativas

En estos histogramas, es común superponer una curva que estime la densidad de la distribución de la variable cuantitativa definida por la característica que estamos midiendo.

La densidad de una variable es una curva cuya área comprendida entre el eje de las abcisas y la propia curva sobre un intervalo es igual a la fracción de individuos de la población que caen dentro de ese intervalo.


## Función density de R

Una de ellas es mediante la función `density` de R. Al aplicarla a un conjunto de datos, produce una `list` que incluye los vectores `x` e `y` que continen la primera y segunda coordenadas, respectivamente, de 512 puntos de la forma $(x,y)$ sobre la curva de densidad estimada.

Aplicando `plot` o `lines` a este resultado según pertoque, obtenemos la representación gráfica de esta curva.

### Función para representar el histograma de frecuencias en R

Aquí os dejamos una función útil para calcular histogramas de frecuencias relativas más completos:

```{r}
histRel = function(x,L) {
  h = hist(x, breaks=L, right=FALSE , plot=FALSE)
  t = round(1.1*max(max(density(x)[[2]]),h$density),2) 
  plot(h, freq = FALSE, col = "lightgray", 
       main = "Histograma de frec. relativas\ny curva de densidad estimada", 
       xaxt="n", ylim=c(0,t), xlab="Intervalos", ylab="Densidades")
  axis(1, at = L) 
  text(h$mids, h$density/2, labels = round(h$counts/length(x),2), col = "blue")
  lines(density(x), col = "purple", lwd = 2) 
  }

set.seed(1)
edades = c(sample(0:99,80,replace = TRUE),rep(35,10),rep(22,5),rep(17,3),50,50)
set.seed(NULL)
extremos = c(0,20,40,60,80,100)
par(mfrow=c(1, 2))
histRel(edades, extremos)
rug(jitter(edades))
par(mfrow=c(1,1))

```


## Histogramas de frecuencias relativas acumuladas

En este último tipo de histograma, se suele superponer una curva que estime la función de distribución de la variable definida por la característica que estamos midiendo.En general, la función de distribución en un valor determinado se obtiene hallando el área de la función de densidad que hay a la izquierda del valor.

La función cumsum sobre density acumula esos valores obtenidos por la función de densidad 


## Función para representar el histograma de frecuencias relativas acumuladas


```{r}
histRelCum = function(x,L){
  h = hist(x, breaks = L, right = FALSE , plot = FALSE)
  h$density = cumsum(h$counts)/length(x)
  plot(h, freq = FALSE, 
      main = "Histograma de frec. rel. acumuladas\n y curva de distribución estimada", 
      xaxt = "n", col = "lightgray", xlab = "Intervalos", 
      ylab = "Frec. relativas acumuladas") 
  axis(1, at = L)
  text(h$mids, h$density/2, labels = round(h$density ,2), col = "blue")
  dens.x = density(x)
  dens.x$y = cumsum(dens.x$y)*(dens.x$x[2]-dens.x$x[1]) 
  lines(dens.x,col = "purple",lwd = 2)
}
set.seed(1)
edades = c(sample(0:99,80,replace = TRUE),rep(35,10),rep(22,5),rep(17,3),50,50)
set.seed(NULL)
extremos = c(0,20,40,60,80,100)
par(mfrow=c(1, 2))
histRelCum(edades, extremos)
rug(jitter(edades))
par(mfrow=c(1,1))

```


## Ejemplo cangrejos

Dibujamos el histograma con `hist` y luego observamos su información interna.

```{r}
hist(cw, breaks = L, right = FALSE, main = "Histograma de las anchuras de los cangrejos")
```
La estructrua itnerna nos da la información de los intervalos. 

```{r}
hist(cw, breaks = L, right = FALSE, plot = FALSE)
```
Dibujamos el histograma con `histAbs`, que premite ver las frecuencias absolutas de cada nivel.

```{r}
histAbs(cw,L)
```

Dibujamos el histograma con `histAbsCum`, una función ya preparada para mostrar las frecuencias bsolutas acumuladas de cada nivel. Con rug para mostrar más información sobre cómo se distribuyen las muestras.

```{r}
histAbsCum(cw,L)
rug(jitter(cw))
```
Calculamos la densidad de `cw`, vemos su estructura con str y la representamos con la función `histRel`

```{r}
str(density(cw))
histRel(cw,L)
```
La curva de densidad que hemos obtenemos en este gráfico tiene una forma de campana que nos recuerda la campana de Gauss. Para explorar este parecido, vamos a añadir al histograma la gráfica de la función densidad de una distribución normal de media y desviación típica las del conjunto de datos original

Dibujamos el histograma de frecuencias relativas acumuladas con la función personalizada `histRelCum`.

```{r}
histRelCum(cw,L)
```